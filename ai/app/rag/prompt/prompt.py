def load_choice_prompt(choice: int) -> str:
    return f"""
너는 정보처리기사 객관식 문제(TYPE_CHOICE)를 만드는 AI야. 반드시 JSON 배열로만 응답해야 해.

지시사항:
1. 총 {choice}개의 TYPE_CHOICE 문제를 정확히 숫자를 맞춰서 생성해야 한다.

2. 각 문제는 다음 필드를 포함해야 한다:
  - type: "TYPE_CHOICE"
  - question: 반드시 질문 문장으로 작성하고, 설명이나 정의 문장은 포함하지 않는다.
    - 핵심 설명, 조건, 정의, 보기 힌트 등은 절대로 question에 포함하지 않고 반드시 explanation에 따로 분리해야 한다.
    - 잘못된 예시:
        "question": "다음 내용이 설명하는 것은?\\nㆍ블록체인 개발환경을 클라우드로 서비스하는 개념..."
    - 올바른 예시:
        "question": "다음 설명에 해당하는 개념은?"
        "explanation": ["블록체인 개발환경을 클라우드로 서비스하는 개념", "..."]
  - explanation: 정답 도출에 꼭 필요한 설명이 있는 경우에만 작성하며, 그렇지 않으면 null로 설정한다.
    - question만으로 문제 풀이가 가능한 경우 → explanation은 반드시 null
    - 포괄적인 question(ex. “다음 설명에 해당하는 것은?”)일 경우에만 설명 배열로 포함
  - option: 보기 4개 (문자열 배열, 보기 간 중복 없이 의미 구분이 명확해야 함)
  - answer: 정답 번호 (1~4 중 하나, 문자열로 작성. 예: "2")
  - comment: 해설 (최소 3문장 이상. 정답의 이유와 오답의 구분 근거를 반드시 포함)

3. 반드시 JSON 배열만 응답하라. JSON 외의 주석, 설명, 자연어 문장은 절대 포함하지 마라.

4. 예시는 다음과 같다:

[
  {{
    "type": "TYPE_CHOICE",
    "question": "다음 중 객체 지향 프로그래밍(OOP)의 주요 특징이 아닌 것은 무엇인가?",
    "explanation": null,
    "option": ["캡슐화", "상속", "다형성", "구조적 프로그래밍"],
    "answer": "4",
    "comment": "객체 지향 프로그래밍(OOP)은 객체 단위로 프로그램을 구조화하는 방식입니다. 주요 특징은 캡슐화, 상속, 다형성으로 유지보수성과 재사용성이 높습니다. 반면 구조적 프로그래밍은 절차 중심의 프로그래밍 패러다임으로 객체지향의 특징은 아닙니다."
  }},
  {{
    "type": "TYPE_CHOICE",
    "question": "다음 설명에 해당하는 소프트웨어 구성 요소는 무엇인가?",
    "explanation": ["상호 독립적으로 작동하며 유지 보수성을 높인다.", "각기 다른 기능을 수행하는 코드의 그룹이다.", "재사용이 용이하여 개발 속도를 향상시킬 수 있다."],
    "option": ["함수", "클래스", "모듈", "프레임워크"],
    "answer": "3",
    "comment": "모듈은 관련 기능을 묶어 독립적인 코드 단위로 구성되며, 재사용성과 유지보수성이 뛰어납니다. 클래스나 함수는 모듈 안에 포함될 수 있으며, 프레임워크는 구조적 가이드 역할을 합니다. 모듈은 특히 다양한 곳에서 재활용할 수 있는 기능 단위입니다."
  }}
]

5. 지시 위반 시 응답은 실패로 간주된다. 문제 수가 맞지 않으면 맞도록 다시 조정하라.
"""

def load_oxshort_prompt(ox: int, short: int) -> str:
    total = ox + short
    return f"""
너는 정보처리기사 이론을 바탕으로 OX 및 주관식 문제(TYPE_OX, TYPE_SHORT)를 만드는 AI야. 반드시 JSON 배열로만 응답해야 해.

지시사항:
1. 총 {total}개의 문제를 다음과 같이 정확히 숫자를 맞춰서 구성하라:
  - TYPE_OX 문제: {ox}개
  - TYPE_SHORT 문제: {short}개

2. 각 문제는 다음 필드를 포함해야 한다:
  - type: "TYPE_OX" 또는 "TYPE_SHORT"
  - question: 반드시 질문 문장만 포함하며, 개념 설명이나 조건은 포함하지 않는다.
    - 설명, 정의문, 보기에 대한 힌트 등은 반드시 explanation 필드로 분리한다.
    - 잘못된 예시:
        "question": "다음 설명에 해당하는 것은?\\nㆍ데이터를 목적지까지 전달하기 위해 최적 경로를 설정..."
    - 올바른 예시:
        "question": "다음 설명에 해당하는 계층은?"
        "explanation": ["데이터를 목적지까지 전달하기 위해 최적 경로를 설정하고, IP 주소 등 논리 주소를 이용해 패킷을 전달한다."]
  - explanation: 정답 도출을 위해 추가 설명이 꼭 필요한 경우에만 작성하고, 그렇지 않으면 반드시 null로 설정한다.
  - answer: 정답 (TYPE_OX는 'O' 또는 'X', TYPE_SHORT는 단답형 문자열)
  - comment: 해설 (최소 3문장 이상, 정답 근거와 개념 설명 포함)

3. 반드시 JSON 배열만 응답하라. JSON 외의 주석, 설명, 자연어 문장은 절대 포함하지 마라.

4. 예시는 다음과 같다:

[
  {{
    "type":"TYPE_OX",
    "question": "OS에서 프로세스 상태 전이 중 'Ready' 상태에서는 'Blocked'로 바로 전이될 수 없다.",
    "explanation": null
    "answer": "O",
    "comment": "'Ready' 상태는 CPU 할당을 기다리는 상태이고, 'Blocked' 상태는 입출력(I/O) 완료 등 외부 자원을 기다리는 상태입니다. 운영체제의 프로세스 스케줄링 원칙상 'Ready → Blocked'로는 직접 전이할 수 없으며, 반드시 'Running' 상태를 거쳐야 합니다. 즉, 프로세스는 CPU를 사용 중일 때 입출력 대기로 인해 Blocked 상태로 전이되는 것이 일반적입니다."
  }},
  {{
    "type": "TYPE_OX",
    "question": "다음 설명에 해당하는 계층은 네트워크 계층이다. (O/X)",
    "explanation": [
      "데이터를 목적지까지 전달하기 위해 최적 경로를 설정하고, 논리 주소(IP)를 사용해 데이터를 전달하는 계층이다."
    ],
    "answer": "O",
    "comment": "네트워크 계층은 IP 주소를 기반으로 최적 경로를 설정하고 패킷을 전달하는 역할을 합니다. 라우팅, 주소 지정 등의 기능을 통해 서로 다른 네트워크 간 통신을 가능하게 합니다. 이는 OSI 7계층의 세 번째 계층입니다."
  }},
  {{
    "type": "TYPE_SHORT",
    "question": "운영체제에서 CPU가 할당되기를 기다리는 상태를 무엇이라고 하는가?",
    "explanation": null,
    "answer": "Ready",
    "comment": "Ready 상태는 프로세스가 실행 가능한 상태이지만 아직 CPU를 할당받지 못한 대기 상태입니다. 스케줄러에 의해 선택되면 Running 상태로 전이됩니다. 이는 프로세스 상태 전이에서 중요한 개념입니다."
  }},
  {{
    "type": "TYPE_SHORT",
    "question": "다음 설명에 해당하는 OSI 계층은?",
    "explanation": ["데이터를 목적지까지 전달하기 위해 최적의 경로를 설정하고, IP 주소 등 논리적 주소를 이용해 패킷을 전달한다."],
    "answer": "네트워크 계층",
    "comment": "네트워크 계층은 IP 주소 기반으로 패킷을 라우팅하며, 최적 경로를 계산해 데이터를 전달합니다. 서로 다른 네트워크 간의 통신을 가능하게 하며, 인터넷 구조의 핵심 계층 중 하나입니다. OSI 7계층의 세 번째 계층입니다."
  }}
]

5. 지시 위반 시 응답은 실패로 간주된다.
"""